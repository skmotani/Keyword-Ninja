Suggested percentile slabs (practical for SEO work)

For ~1000–3000 pages per client, a good, workable split is:

Tier 1 – Immediate (Top 10%)
→ Pages you actively work on in the next few sprints

Tier 2 – High Priority (Next 20%)
→ Strong second wave; build/optimize over 1–3 months

Tier 3 – Medium (Next 30%)
→ Cluster support / long-term

Tier 4 – Monitor (Next 20%)
→ Just watch performance / SERP

Tier 5 – Ignore (Bottom 20%)
→ No active SEO work

We’ll implement it like this using Priority Score percentiles per client:

Compute percentiles on priorityScore:

P90, P70, P40, P20

Then:

if score >= P90         → TIER_1_IMMEDIATE      (top 10%)
else if score >= P70    → TIER_2_HIGH           (next 20%)
else if score >= P40    → TIER_3_MEDIUM         (next 30%)
else if score >= P20    → TIER_4_MONITOR        (next 20%)
else                    → TIER_5_IGNORE         (bottom 20%)


This means Tier 1 will always exist and will always be “the top slice” of your actual data, not some unreachable theoretical value.

2️⃣ Replit prompt – percentile-based Priority Tier (copy–paste)

Here’s the prompt you can give to Replit AI / Ghostwriter to implement this change.

REPLIT PROMPT:

I already have a Priority Score system implemented for my “Competitor Top Pages” dataset.

Current situation:

Backend model has fields like:

priorityScore: number | null (0–100)

priorityTier: "TIER_1_IMMEDIATE" | "TIER_2_HIGH" | "TIER_3_MEDIUM" | "TIER_4_MONITOR" | "TIER_5_IGNORE" | null

plus supporting fields (etvNormalizedScore, intentScore, pageTypeScore, businessRelevanceScore, priorityExplanation)

Priority Score is calculated correctly using:

ETV (Estimated Traffic Value)

Page Intent

Page Type

Business Relevance

Currently, priorityTier is assigned via fixed numeric cutoffs (e.g. >=80 = Tier 1, etc.).

In practice, this leads to 0 rows in Tier 1 for some clients, because real scores are bunched around 30–65.

I now want to change the tier assignment to be percentile-based per client.

1. Change Tier logic to percentiles

Create / update a function (e.g. in priorityScoring.ts or a new module) to compute tier thresholds from percentiles of priorityScore for each client.

Concept:

For a given client (or project), fetch all rows with a non-null priorityScore.

Compute these percentiles:

P90 (90th percentile)

P70 (70th percentile)

P40 (40th percentile)

P20 (20th percentile)

Implement a helper:

function getPercentileThreshold(values: number[], percentile: number): number | null {
  // values: non-null priorityScore values
  // percentile: 0–100
  // return the value at that percentile (e.g. 90 → P90)
}


Use a standard percentile calculation:

Sort values ascending.

For N values, the index = percentile / 100 * (N - 1).

If index is integer → take that value.

If fractional → interpolate between neighboring values.

Return null if the list is empty.

2. Tier assignment rules (using percentiles)

Once P90, P70, P40, P20 are computed for the client:

type PriorityTier =
  | "TIER_1_IMMEDIATE"  // Top 10%
  | "TIER_2_HIGH"       // Next 20%
  | "TIER_3_MEDIUM"     // Next 30%
  | "TIER_4_MONITOR"    // Next 20%
  | "TIER_5_IGNORE";    // Bottom 20%

function assignTierFromPercentiles(
  score: number | null,
  thresholds: {
    p90: number | null;
    p70: number | null;
    p40: number | null;
    p20: number | null;
  }
): PriorityTier | null {
  if (score == null) return null;

  const { p90, p70, p40, p20 } = thresholds;

  // handle edge cases: if thresholds are null (e.g. not enough data),
  // you can either fallback to fixed numeric thresholds or collapse everything into medium/monitor.

  if (p90 != null && score >= p90) return "TIER_1_IMMEDIATE";
  if (p70 != null && score >= p70) return "TIER_2_HIGH";
  if (p40 != null && score >= p40) return "TIER_3_MEDIUM";
  if (p20 != null && score >= p20) return "TIER_4_MONITOR";
  return "TIER_5_IGNORE";
}


Notes:

Keep this separate from the score calculation. calculatePriority() should still just compute priorityScore; tiering is a second step.

For very small datasets (e.g. < 10