'use client';

import React, { useState, useEffect, useMemo, useCallback } from 'react';
import Link from 'next/link';

// =============================================================================
// TYPES
// =============================================================================

interface Client { code: string; name: string; mainDomain: string; isActive: boolean; }

interface KeywordRow {
    id: string;
    keyword: string;
    volume: number;
    position: number | null;
    locationCode: string;
    url: string | null;
    sourceBucket: string;
    effectiveBucket: string;
    isOverridden: boolean;
    isExcluded: boolean;
}

interface ClusterKeyword {
    keyword: string;
    volume: number;
    position: number | null;
    bucket: string;
    locationCode: string;
    isOverridden: boolean;
}

interface Cluster {
    id: string;
    label: string;
    size: number;
    totalVolume: number;
    avgPosition: number;
    bucketMix: Record<string, number>;
    origin: 'auto' | 'volume_combined' | 'volume_single' | 'manual' | 'hybrid';
    opportunityScore: number;
    opportunityBreakdown: { demand: number; visibility: number; coverage: number; commercial: number };
    keywords: ClusterKeyword[];
    isLocked: boolean;
}

interface UnclusteredKeyword {
    keyword: string;
    volume: number;
    position: number | null;
    bucket: string;
    reason: string;
}

interface ClusteringStats {
    keywordsConsidered: number;
    clustersCreated: number;
    clusteredKeywords: number;
    unclusteredKeywords: number;
    unclusteredPct: number;
    reasonBreakdown: Record<string, number>;
}

type MainTab = 'keywords' | 'clusters' | 'final' | 'intent';
type ClusterSubTab = 'all' | 'clustered' | 'unclustered';
type ClusteringScope = 'include-both' | 'include-buy' | 'include-learn' | 'brand-nav';
type ClusterPolicy = 'topic' | 'bucket-separated';

const BUCKETS = [
    { key: 'include', label: 'Include | Buy', color: 'bg-green-100 text-green-700' },
    { key: 'review', label: 'Include | Learn', color: 'bg-blue-100 text-blue-700' },
    { key: 'brand', label: 'Brand | Nav', color: 'bg-purple-100 text-purple-700' },
    { key: 'exclude', label: 'Exclude | Noise', color: 'bg-red-100 text-red-700' }
];

const ORIGIN_LABELS: Record<string, { label: string; color: string; tooltip: string }> = {
    'auto': { label: 'Auto', color: 'bg-gray-100 text-gray-600', tooltip: 'Generated by TF-IDF clustering algorithm' },
    'manual': { label: 'Manual', color: 'bg-indigo-100 text-indigo-700', tooltip: 'Created manually by you from unclustered keywords' },
    'hybrid': { label: 'Hybrid', color: 'bg-amber-100 text-amber-700', tooltip: 'Auto-generated cluster with manual keyword additions' },
    'singleton': { label: 'Singleton', color: 'bg-orange-100 text-orange-700', tooltip: 'High-volume keyword promoted as its own cluster' },
    'volume_combined': { label: 'Vol+', color: 'bg-teal-100 text-teal-700', tooltip: 'Combined from micro-clusters by volume' },
    'volume_single': { label: 'Singleton', color: 'bg-green-100 text-green-700', tooltip: 'Single high-volume keyword promoted' }
};

// =============================================================================
// MAIN COMPONENT
// =============================================================================

export default function ClusterIntentStudioPage() {
    // Client
    const [clients, setClients] = useState<Client[]>([]);
    const [clientCode, setClientCode] = useState('');
    const [loading, setLoading] = useState(false);

    // Main tab
    const [mainTab, setMainTab] = useState<MainTab>('keywords');

    // Keywords data
    const [keywords, setKeywords] = useState<KeywordRow[]>([]);
    const [overrides, setOverrides] = useState<Record<string, { bucket?: string; excluded?: boolean }>>(() => {
        if (typeof window !== 'undefined') {
            const saved = localStorage.getItem('cluster-studio-overrides');
            return saved ? JSON.parse(saved) : {};
        }
        return {};
    });

    // Filters (Tab 1)
    const [searchFilter, setSearchFilter] = useState('');
    const [locationFilter, setLocationFilter] = useState('all');
    const [bucketFilters, setBucketFilters] = useState<string[]>(['include', 'review', 'brand']);
    const [minVolume, setMinVolume] = useState(0);
    const [maxPosition, setMaxPosition] = useState(100);
    const [selectedRows, setSelectedRows] = useState<Set<string>>(new Set());
    const [sortField, setSortField] = useState<'keyword' | 'volume' | 'position' | 'bucket'>('volume');
    const [sortDir, setSortDir] = useState<'asc' | 'desc'>('desc');

    // Clustering (Tab 2)
    const [scope, setScope] = useState<ClusteringScope>('include-both');
    const [policy, setPolicy] = useState<ClusterPolicy>('topic');
    const [granularity, setGranularity] = useState(45);
    const [minClusterSize, setMinClusterSize] = useState(2);
    const [clustering, setClustering] = useState(false);

    // Cluster results
    const [clusters, setClusters] = useState<Cluster[]>([]);
    const [unclustered, setUnclustered] = useState<UnclusteredKeyword[]>([]);
    const [stats, setStats] = useState<ClusteringStats | null>(null);
    const [clusterSubTab, setClusterSubTab] = useState<ClusterSubTab>('all');

    // Draft changes
    const [draftChanges, setDraftChanges] = useState(0);
    const [needsRegenerate, setNeedsRegenerate] = useState(false);

    // Saved clusters (Final)
    const [savedClusters, setSavedClusters] = useState<Cluster[]>([]);
    const [hasSaved, setHasSaved] = useState(false);
    const [storageLoaded, setStorageLoaded] = useState(false);

    // Review drawer
    const [drawerCluster, setDrawerCluster] = useState<Cluster | null>(null);
    const [notification, setNotification] = useState<{ type: 'success' | 'error'; msg: string } | null>(null);

    // Unclustered tab state
    const [unclusteredFilter, setUnclusteredFilter] = useState('');
    const [selectedUnclustered, setSelectedUnclustered] = useState<Set<string>>(new Set());
    const [clusterSearch, setClusterSearch] = useState('');
    const [showClusterDropdown, setShowClusterDropdown] = useState(false);
    const [clusterListSearch, setClusterListSearch] = useState('');
    const [manuallyAdded, setManuallyAdded] = useState<Record<string, number>>({});

    const [finalClusterSearch, setFinalClusterSearch] = useState('');
    const [finalClusterSort, setFinalClusterSort] = useState<'size' | 'volume' | 'opportunity'>('opportunity');
    const [finalClusterSortDir, setFinalClusterSortDir] = useState<'asc' | 'desc'>('desc');
    const [expandedFinalCluster, setExpandedFinalCluster] = useState<string | null>(null);
    const [finalClusterOriginFilter, setFinalClusterOriginFilter] = useState<'all' | 'manual' | 'hybrid' | 'auto'>('all');

    // Unclustered table sort
    const [unclusteredSort, setUnclusteredSort] = useState<'keyword' | 'volume' | 'bucket' | 'reason'>('volume');
    const [unclusteredSortDir, setUnclusteredSortDir] = useState<'asc' | 'desc'>('desc');
    const [unclusteredReasonFilter, setUnclusteredReasonFilter] = useState<string>('all');

    // Intent Classification state
    const [intentResults, setIntentResults] = useState<{
        clientCode: string;
        timestamp: string;
        clusters: Array<{
            clusterId: string;
            clusterName: string;
            intentPrimary: string;
            intentSecondary: string | null;
            distribution: Record<string, number>;
            confidence: number;
            reasonCodes: string[];
            llmChecked: boolean;
            llmOverride: boolean;
            llmNotes: string | null;
            keywords: Array<{
                keyword: string;
                volume: number;
                intentPrimary: string;
                intentProbs: Record<string, number>;
                confidence: number;
                matchedRules: string[];
            }>;
            totalVolume: number;
            keywordCount: number;
        }>;
        summary: Record<string, { clusters: number; keywords: number; volume: number }>;
    } | null>(null);
    const [intentLoading, setIntentLoading] = useState(false);
    const [intentFilter, setIntentFilter] = useState<string>('all');
    const [intentSort, setIntentSort] = useState<'confidence' | 'volume'>('confidence');
    const [intentSortDir, setIntentSortDir] = useState<'asc' | 'desc'>('desc');
    const [expandedIntentCluster, setExpandedIntentCluster] = useState<string | null>(null);
    const [intentSearch, setIntentSearch] = useState('');

    // =============================================================================
    // DATA LOADING
    // =============================================================================

    // Load from localStorage on mount
    useEffect(() => {
        try {
            const savedOverrides = localStorage.getItem('cluster-studio-overrides');
            if (savedOverrides) setOverrides(JSON.parse(savedOverrides));

            const savedClustersData = localStorage.getItem('cluster-studio-saved');
            if (savedClustersData) {
                const parsed = JSON.parse(savedClustersData);
                setSavedClusters(parsed);
                setHasSaved(parsed.length > 0);
            }

            // Load draft clusters (Topic Clusters tab working state)
            const draftData = localStorage.getItem('cluster-studio-draft');
            if (draftData) {
                const draft = JSON.parse(draftData);
                if (draft.clusters) setClusters(draft.clusters);
                if (draft.unclustered) setUnclustered(draft.unclustered);
                if (draft.stats) setStats(draft.stats);
                if (draft.manuallyAdded) setManuallyAdded(draft.manuallyAdded);
            }
        } catch (e) {
            console.error('Failed to load from localStorage:', e);
        }
        setStorageLoaded(true);
    }, []);

    useEffect(() => {
        fetch('/api/clients').then(r => r.json()).then(data => {
            const active = data.filter((c: Client) => c.isActive);
            setClients(active);
            if (active.length && !clientCode) setClientCode(active[0].code);
        });
    }, []);

    // Persist overrides to localStorage
    useEffect(() => {
        if (storageLoaded && Object.keys(overrides).length > 0) {
            localStorage.setItem('cluster-studio-overrides', JSON.stringify(overrides));
        }
    }, [overrides, storageLoaded]);

    // Persist saved clusters to localStorage
    useEffect(() => {
        if (storageLoaded) {
            localStorage.setItem('cluster-studio-saved', JSON.stringify(savedClusters));
            setHasSaved(savedClusters.length > 0);
        }
    }, [savedClusters, storageLoaded]);

    // Persist draft clusters (Topic Clusters tab) to localStorage
    useEffect(() => {
        if (storageLoaded && (clusters.length > 0 || unclustered.length > 0)) {
            localStorage.setItem('cluster-studio-draft', JSON.stringify({
                clusters,
                unclustered,
                stats,
                manuallyAdded
            }));
        }
    }, [clusters, unclustered, stats, manuallyAdded, storageLoaded]);

    const loadKeywords = useCallback(async () => {
        if (!clientCode) return;
        setLoading(true);
        try {
            const res = await fetch(`/api/domain-keywords?clientCode=${clientCode}`);
            const data = await res.json();
            if (!data.success) throw new Error('Failed');

            // Load AI profile for source buckets
            const profileRes = await fetch(`/api/client-ai-profile?clientCode=${clientCode}`);
            const profile = profileRes.ok ? await profileRes.json() : null;
            const terms = profile?.ai_kw_builder_term_dictionary?.terms || [];
            const bucketMap: Record<string, string> = {};
            terms.forEach((t: any) => bucketMap[t.term.toLowerCase().trim()] = t.bucket);

            // Build keyword rows with source bucket
            const rows: KeywordRow[] = data.records.map((r: any, i: number) => {
                const sourceBucket = bucketMap[r.keyword.toLowerCase().trim()] || 'unassigned';
                const override = overrides[r.keyword.toLowerCase().trim()];
                return {
                    id: `${i}-${r.keyword}`,
                    keyword: r.keyword,
                    volume: r.searchVolume || 0,
                    position: r.position,
                    locationCode: r.locationCode || 'GL',
                    url: r.url,
                    sourceBucket,
                    effectiveBucket: override?.bucket || sourceBucket,
                    isOverridden: !!override?.bucket,
                    isExcluded: override?.excluded || sourceBucket === 'exclude'
                };
            });

            setKeywords(rows);
        } catch (e) {
            console.error(e);
        } finally {
            setLoading(false);
        }
    }, [clientCode, overrides]);

    useEffect(() => { loadKeywords(); }, [loadKeywords]);

    // =============================================================================
    // BUCKET OVERRIDE HANDLERS
    // =============================================================================

    const handleBucketOverride = (keywordIds: string[], newBucket: string | null) => {
        const newOverrides = { ...overrides };
        keywordIds.forEach(id => {
            const kw = keywords.find(k => k.id === id);
            if (!kw) return;
            const key = kw.keyword.toLowerCase().trim();
            if (newBucket === null) {
                delete newOverrides[key];
            } else {
                newOverrides[key] = { ...newOverrides[key], bucket: newBucket };
            }
        });
        setOverrides(newOverrides);

        // Update keywords in-place
        setKeywords(prev => prev.map(k => {
            const key = k.keyword.toLowerCase().trim();
            const override = newOverrides[key];
            return {
                ...k,
                effectiveBucket: override?.bucket || k.sourceBucket,
                isOverridden: !!override?.bucket,
                isExcluded: override?.excluded || k.sourceBucket === 'exclude'
            };
        }));

        if (clusters.length) setNeedsRegenerate(true);
        setSelectedRows(new Set());
    };

    const handleExclude = (keywordIds: string[]) => {
        const newOverrides = { ...overrides };
        keywordIds.forEach(id => {
            const kw = keywords.find(k => k.id === id);
            if (!kw) return;
            const key = kw.keyword.toLowerCase().trim();
            newOverrides[key] = { ...newOverrides[key], excluded: true };
        });
        setOverrides(newOverrides);
        setKeywords(prev => prev.map(k => {
            const key = k.keyword.toLowerCase().trim();
            return { ...k, isExcluded: newOverrides[key]?.excluded || k.sourceBucket === 'exclude' };
        }));
        if (clusters.length) setNeedsRegenerate(true);
        setSelectedRows(new Set());
    };

    const handleResetOverrides = (keywordIds: string[]) => {
        const newOverrides = { ...overrides };
        keywordIds.forEach(id => {
            const kw = keywords.find(k => k.id === id);
            if (!kw) return;
            delete newOverrides[kw.keyword.toLowerCase().trim()];
        });
        setOverrides(newOverrides);
        setKeywords(prev => prev.map(k => ({
            ...k,
            effectiveBucket: k.sourceBucket,
            isOverridden: false,
            isExcluded: k.sourceBucket === 'exclude'
        })));
        if (clusters.length) setNeedsRegenerate(true);
        setSelectedRows(new Set());
    };

    // =============================================================================
    // FILTERING
    // =============================================================================

    const filteredKeywords = useMemo(() => {
        // First filter, then de-duplicate by keyword text (keep highest volume)
        const filtered = keywords.filter(k => {
            if (k.isExcluded) return false;
            if (searchFilter && !k.keyword.toLowerCase().includes(searchFilter.toLowerCase())) return false;
            if (locationFilter !== 'all' && k.locationCode !== locationFilter) return false;
            if (!bucketFilters.includes(k.effectiveBucket)) return false;
            if (k.volume < minVolume) return false;
            if (k.position && k.position > maxPosition) return false;
            return true;
        });

        // De-duplicate: group by lowercase keyword, keep highest volume
        const uniqueMap = new Map<string, KeywordRow>();
        filtered.forEach(k => {
            const key = k.keyword.toLowerCase().trim();
            const existing = uniqueMap.get(key);
            if (!existing || k.volume > existing.volume) {
                uniqueMap.set(key, k);
            }
        });

        return Array.from(uniqueMap.values());
    }, [keywords, searchFilter, locationFilter, bucketFilters, minVolume, maxPosition]);

    const sortedKeywords = useMemo(() => {
        return [...filteredKeywords].sort((a, b) => {
            let cmp = 0;
            if (sortField === 'keyword') cmp = a.keyword.localeCompare(b.keyword);
            else if (sortField === 'volume') cmp = a.volume - b.volume;
            else if (sortField === 'position') cmp = (a.position || 999) - (b.position || 999);
            else if (sortField === 'bucket') cmp = a.effectiveBucket.localeCompare(b.effectiveBucket);
            return sortDir === 'desc' ? -cmp : cmp;
        });
    }, [filteredKeywords, sortField, sortDir]);

    const clusteringKeywords = useMemo(() => {
        const scopeBuckets = scope === 'include-both' ? ['include', 'review'] :
            scope === 'include-buy' ? ['include'] :
                scope === 'include-learn' ? ['review'] :
                    scope === 'brand-nav' ? ['brand'] : ['include', 'review'];

        // Filter by scope, then de-duplicate
        const filtered = keywords.filter(k => !k.isExcluded && scopeBuckets.includes(k.effectiveBucket));
        const uniqueMap = new Map<string, KeywordRow>();
        filtered.forEach(k => {
            const key = k.keyword.toLowerCase().trim();
            const existing = uniqueMap.get(key);
            if (!existing || k.volume > existing.volume) {
                uniqueMap.set(key, k);
            }
        });

        return Array.from(uniqueMap.values());
    }, [keywords, scope]);

    // =============================================================================
    // CLUSTERING
    // =============================================================================

    const handleGenerateClusters = async () => {
        if (!clusteringKeywords.length) return;
        setClustering(true);
        setNeedsRegenerate(false);

        try {
            const res = await fetch('/api/keywords/cluster', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    keywords: clusteringKeywords.map(k => ({
                        keyword: k.keyword,
                        volume: k.volume,
                        position: k.position,
                        bucket: k.effectiveBucket,
                        locationCode: k.locationCode
                    })),
                    granularity,
                    minClusterSize,
                    clusterPolicy: policy
                })
            });

            const data = await res.json();
            if (!data.success) throw new Error(data.error);

            // Map API response
            const mappedClusters: Cluster[] = data.clusters.map((c: any) => ({
                id: c.cluster_id,
                label: c.cluster_label,
                size: c.cluster_size,
                totalVolume: c.total_volume,
                avgPosition: c.avg_position,
                bucketMix: c.bucket_mix,
                origin: c.cluster_origin,
                opportunityScore: c.opportunity_score,
                opportunityBreakdown: {
                    demand: c.opportunity_breakdown?.demand_score || 0,
                    visibility: c.opportunity_breakdown?.visibility_gap_score || 0,
                    coverage: c.opportunity_breakdown?.coverage_score || 0,
                    commercial: c.opportunity_breakdown?.commerciality_score || 0
                },
                keywords: c.keywords.map((k: any) => ({
                    keyword: k.keyword,
                    volume: k.volume,
                    position: k.position,
                    bucket: k.bucket,
                    locationCode: 'GL',
                    isOverridden: false
                })),
                isLocked: c.is_locked || false
            }));

            const mappedUnclustered: UnclusteredKeyword[] = data.keywords
                .filter((k: any) => k.unclustered_reason)
                .map((k: any) => ({
                    keyword: k.keyword_raw,
                    volume: k.volume,
                    position: k.position,
                    bucket: k.bucket,
                    reason: k.unclustered_reason
                }));

            setClusters(mappedClusters);
            setUnclustered(mappedUnclustered);
            setStats({
                keywordsConsidered: data.stats.keywords_considered,
                clustersCreated: data.stats.clusters_created,
                clusteredKeywords: data.stats.clustered_keywords,
                unclusteredKeywords: data.stats.unclustered_keywords,
                unclusteredPct: data.stats.unclustered_percentage,
                reasonBreakdown: data.unclustered_summary?.by_reason || {}
            });
            setDraftChanges(0);
            setMainTab('clusters');
            setNotification({ type: 'success', msg: `${mappedClusters.length} clusters, ${mappedUnclustered.length} unclustered` });
        } catch (e: any) {
            setNotification({ type: 'error', msg: e.message });
        } finally {
            setClustering(false);
        }
    };

    // =============================================================================
    // UNCLUSTERED ACTIONS
    // =============================================================================

    const addToCluster = (keyword: string, clusterId: string) => {
        const target = clusters.find(c => c.id === clusterId);
        const kw = unclustered.find(u => u.keyword === keyword);
        if (!target || !kw) return;

        setClusters(prev => prev.map(c => {
            if (c.id !== clusterId) return c;
            return {
                ...c,
                keywords: [...c.keywords, { keyword: kw.keyword, volume: kw.volume, position: kw.position, bucket: kw.bucket, locationCode: 'GL', isOverridden: true }],
                size: c.size + 1,
                totalVolume: c.totalVolume + kw.volume,
                origin: c.origin === 'auto' ? 'hybrid' : c.origin
            };
        }));
        setUnclustered(prev => prev.filter(u => u.keyword !== keyword));
        setManuallyAdded(prev => ({ ...prev, [clusterId]: (prev[clusterId] || 0) + 1 }));
        setDraftChanges(d => d + 1);
        setNotification({ type: 'success', msg: `Added "${keyword}" to "${target.label}"` });
        setTimeout(() => setNotification(null), 3000);
    };

    const createClusterFromUnclustered = (keywordNames: string[]) => {
        const kws = unclustered.filter(u => keywordNames.includes(u.keyword));
        if (!kws.length) return;

        const newCluster: Cluster = {
            id: `manual-${Date.now()}`,
            label: kws[0].keyword.split(' ').slice(0, 3).map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' '),
            size: kws.length,
            totalVolume: kws.reduce((s, k) => s + k.volume, 0),
            avgPosition: kws.filter(k => k.position).reduce((s, k) => s + (k.position || 0), 0) / kws.filter(k => k.position).length || 0,
            bucketMix: kws.reduce((acc, k) => ({ ...acc, [k.bucket]: (acc[k.bucket] || 0) + 1 }), {} as Record<string, number>),
            origin: 'manual',
            opportunityScore: 50,
            opportunityBreakdown: { demand: 50, visibility: 50, coverage: 30, commercial: 40 },
            keywords: kws.map(k => ({ keyword: k.keyword, volume: k.volume, position: k.position, bucket: k.bucket, locationCode: 'GL', isOverridden: false })),
            isLocked: false
        };

        setClusters(prev => [newCluster, ...prev]);
        setUnclustered(prev => prev.filter(u => !keywordNames.includes(u.keyword)));
        setDraftChanges(d => d + 1);
    };

    const excludeUnclustered = (keyword: string) => {
        const kw = keywords.find(k => k.keyword === keyword);
        if (kw) handleExclude([kw.id]);
        setUnclustered(prev => prev.filter(u => u.keyword !== keyword));
        setDraftChanges(d => d + 1);
    };

    // =============================================================================
    // DRAWER ACTIONS
    // =============================================================================

    const removeFromCluster = (clusterId: string, keyword: string) => {
        const cluster = clusters.find(c => c.id === clusterId);
        const kw = cluster?.keywords.find(k => k.keyword === keyword);
        if (!kw) return;

        setClusters(prev => prev.map(c => {
            if (c.id !== clusterId) return c;
            const updated = c.keywords.filter(k => k.keyword !== keyword);
            return { ...c, keywords: updated, size: updated.length, totalVolume: updated.reduce((s, k) => s + k.volume, 0) };
        }).filter(c => c.size > 0));

        setUnclustered(prev => [...prev, { keyword: kw.keyword, volume: kw.volume, position: kw.position, bucket: kw.bucket, reason: 'manual_removed' }]);
        setDraftChanges(d => d + 1);
    };

    const toggleClusterLock = (clusterId: string) => {
        setClusters(prev => prev.map(c => c.id === clusterId ? { ...c, isLocked: !c.isLocked } : c));
        setDraftChanges(d => d + 1);
    };

    // =============================================================================
    // SAVE
    // =============================================================================

    const handleSave = () => {
        setSavedClusters([...clusters]);
        setHasSaved(true);
        setDraftChanges(0);
        setMainTab('final');
        setNotification({ type: 'success', msg: `Saved ${clusters.length} clusters` });
    };

    // =============================================================================
    // EXPORT
    // =============================================================================

    const exportCSV = (data: Cluster[], filename: string) => {
        const headers = ['Cluster', 'Size', 'Volume', 'Avg Pos', 'Origin', 'Opportunity', 'Keywords'];
        const rows = data.map(c => [c.label, c.size, c.totalVolume, c.avgPosition.toFixed(1), c.origin, c.opportunityScore, c.keywords.map(k => k.keyword).join('; ')]);
        const csv = [headers.join(','), ...rows.map(r => r.map(c => `"${c}"`).join(','))].join('\n');
        const blob = new Blob([csv], { type: 'text/csv' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
    };

    // =============================================================================
    // RENDER HELPERS
    // =============================================================================

    const BucketBadge = ({ bucket }: { bucket: string }) => {
        const b = BUCKETS.find(x => x.key === bucket);
        return <span className={`px-1.5 py-0.5 rounded text-xs ${b?.color || 'bg-gray-100 text-gray-600'}`}>{b?.label || bucket}</span>;
    };

    const OpportunityBadge = ({ score }: { score: number }) => {
        const color = score >= 70 ? 'bg-green-100 text-green-700' : score >= 40 ? 'bg-amber-100 text-amber-700' : 'bg-gray-100 text-gray-600';
        return <span className={`px-2 py-0.5 rounded text-xs font-medium ${color}`}>{score}</span>;
    };

    // =============================================================================
    // RENDER
    // =============================================================================

    return (
        <div className="min-h-screen bg-gradient-to-br from-slate-50 to-indigo-50">
            {/* Notification */}
            {notification && (
                <div className={`fixed top-4 right-4 z-50 px-4 py-3 rounded-lg shadow-lg ${notification.type === 'success' ? 'bg-green-500' : 'bg-red-500'} text-white`}>
                    {notification.msg}
                    <button onClick={() => setNotification(null)} className="ml-4 font-bold">√ó</button>
                </div>
            )}

            {/* Drawer */}
            {drawerCluster && (
                <div className="fixed inset-0 z-50 flex">
                    <div className="absolute inset-0 bg-black/30" onClick={() => setDrawerCluster(null)}></div>
                    <div className="absolute right-0 top-0 bottom-0 w-full max-w-2xl bg-white shadow-xl flex flex-col">
                        <div className="p-4 border-b bg-gray-50 flex items-center justify-between">
                            <div>
                                <h2 className="text-lg font-bold">{drawerCluster.label}</h2>
                                <div className="text-sm text-gray-500">{drawerCluster.size} keywords ‚Ä¢ {drawerCluster.totalVolume.toLocaleString()} vol</div>
                            </div>
                            <div className="flex items-center gap-2">
                                <button onClick={() => toggleClusterLock(drawerCluster.id)} className={`px-2 py-1 rounded text-xs ${drawerCluster.isLocked ? 'bg-amber-100 text-amber-700' : 'bg-gray-100'}`}>
                                    {drawerCluster.isLocked ? 'üîí Locked' : 'üîì Lock'}
                                </button>
                                <button onClick={() => setDrawerCluster(null)} className="p-2 hover:bg-gray-200 rounded">‚úï</button>
                            </div>
                        </div>

                        {/* Importance Matrix */}
                        <div className="p-4 bg-gradient-to-r from-indigo-50 to-purple-50 border-b">
                            <h3 className="text-sm font-bold mb-2">Why This Cluster Matters</h3>
                            <div className="grid grid-cols-4 gap-2 text-center mb-2">
                                <div className="bg-white rounded p-2 border"><div className="text-xs text-gray-500">Demand</div><div className="font-bold">{drawerCluster.opportunityBreakdown.demand >= 70 ? 'High' : drawerCluster.opportunityBreakdown.demand >= 40 ? 'Med' : 'Low'}</div></div>
                                <div className="bg-white rounded p-2 border"><div className="text-xs text-gray-500">Visibility</div><div className="font-bold">{drawerCluster.opportunityBreakdown.visibility >= 70 ? 'High' : drawerCluster.opportunityBreakdown.visibility >= 40 ? 'Med' : 'Low'}</div></div>
                                <div className="bg-white rounded p-2 border"><div className="text-xs text-gray-500">Coverage</div><div className="font-bold">{drawerCluster.size >= 10 ? 'Broad' : 'Narrow'}</div></div>
                                <div className="bg-white rounded p-2 border"><div className="text-xs text-gray-500">Commercial</div><div className="font-bold">{drawerCluster.opportunityBreakdown.commercial >= 70 ? 'High' : drawerCluster.opportunityBreakdown.commercial >= 40 ? 'Med' : 'Low'}</div></div>
                            </div>
                            <div className="flex items-center justify-between">
                                <OpportunityBadge score={drawerCluster.opportunityScore} />
                                <span className="text-xs text-gray-500">High demand + weak rankings = high opportunity</span>
                            </div>
                        </div>

                        {/* Keyword table */}
                        <div className="flex-1 overflow-y-auto">
                            <table className="w-full text-sm">
                                <thead className="bg-gray-50 sticky top-0"><tr>
                                    <th className="text-left px-4 py-2">Keyword</th>
                                    <th className="text-right px-3 py-2">Vol</th>
                                    <th className="text-right px-3 py-2">Pos</th>
                                    <th className="text-center px-3 py-2">Bucket</th>
                                    <th className="px-3 py-2"></th>
                                </tr></thead>
                                <tbody className="divide-y">
                                    {drawerCluster.keywords.sort((a, b) => b.volume - a.volume).map((k, i) => (
                                        <tr key={i} className="hover:bg-gray-50">
                                            <td className="px-4 py-2 font-medium">{k.keyword}</td>
                                            <td className="px-3 py-2 text-right">{k.volume.toLocaleString()}</td>
                                            <td className="px-3 py-2 text-right">{k.position || '-'}</td>
                                            <td className="px-3 py-2 text-center"><BucketBadge bucket={k.bucket} /></td>
                                            <td className="px-3 py-2 text-center">
                                                <button onClick={() => removeFromCluster(drawerCluster.id, k.keyword)} className="text-red-500 text-xs">Remove</button>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            )}

            {/* Header */}
            <header className="bg-white border-b shadow-sm">
                <div className="max-w-7xl mx-auto px-6 py-4 flex items-center justify-between">
                    <div className="flex items-center gap-4">
                        <h1 className="text-xl font-bold flex items-center gap-2">üß† Cluster & Intent Studio</h1>
                        <span className="text-xs bg-purple-100 text-purple-700 px-2 py-0.5 rounded-full">Clustering</span>
                    </div>
                    <div className="flex items-center gap-3">
                        <select value={clientCode} onChange={e => setClientCode(e.target.value)} className="border rounded px-3 py-1.5 text-sm">
                            {clients.map(c => <option key={c.code} value={c.code}>{c.name}</option>)}
                        </select>
                        <span className="text-xs bg-blue-50 text-blue-700 px-2 py-1 rounded border border-blue-200">Domain Top Keywords</span>
                        <button onClick={loadKeywords} disabled={loading} className="px-3 py-1.5 bg-gray-100 rounded text-sm hover:bg-gray-200">‚Üª</button>
                        <button onClick={() => exportCSV(mainTab === 'final' ? savedClusters : clusters, `clusters-${clientCode}.csv`)} disabled={!clusters.length && !savedClusters.length} className="px-3 py-1.5 bg-indigo-600 text-white rounded text-sm disabled:opacity-50">Export CSV</button>
                    </div>
                </div>
            </header>

            {/* Main Tabs */}
            <div className="max-w-7xl mx-auto px-6 py-4">
                <div className="flex gap-1 bg-white rounded-lg p-1 shadow-sm border w-fit mb-4">
                    {(['keywords', 'clusters', 'final', 'intent'] as const).map(t => (
                        <button key={t} onClick={() => setMainTab(t)} className={`px-4 py-2 rounded text-sm font-medium transition-all ${mainTab === t ? 'bg-indigo-100 text-indigo-700' : 'text-gray-600 hover:bg-gray-100'}`}>
                            {t === 'keywords' ? 'üìù Keywords' : t === 'clusters' ? 'üîÆ Topic Clusters' : t === 'final' ? '‚úÖ Final Clusters' : 'üéØ Intent'}
                            {t === 'clusters' && draftChanges > 0 && <span className="ml-1.5 bg-amber-500 text-white text-xs px-1.5 rounded-full">{draftChanges}</span>}
                            {t === 'intent' && intentResults && <span className="ml-1.5 bg-green-500 text-white text-xs px-1.5 rounded-full">‚úì</span>}
                        </button>
                    ))}
                </div>

                {/* Tab 1: Keywords */}
                {mainTab === 'keywords' && (
                    <div className="bg-white rounded-xl shadow-sm border">
                        {/* Regenerate banner */}
                        {needsRegenerate && clusters.length > 0 && (
                            <div className="px-4 py-3 bg-amber-50 border-b border-amber-200 flex items-center justify-between">
                                <span className="text-sm text-amber-800">‚ö†Ô∏è Bucket changes detected. Regenerate clusters to apply.</span>
                                <div className="flex gap-2">
                                    <button onClick={handleGenerateClusters} className="px-3 py-1 bg-amber-600 text-white rounded text-sm">Regenerate now</button>
                                    <button onClick={() => setNeedsRegenerate(false)} className="px-3 py-1 bg-amber-100 text-amber-700 rounded text-sm">Dismiss</button>
                                </div>
                            </div>
                        )}

                        {/* Filters */}
                        <div className="p-4 border-b flex flex-wrap items-center gap-3">
                            <input type="text" placeholder="Filter keywords‚Ä¶" value={searchFilter} onChange={e => setSearchFilter(e.target.value)} className="border rounded px-3 py-1.5 text-sm w-48" />
                            <select value={locationFilter} onChange={e => setLocationFilter(e.target.value)} className="border rounded px-3 py-1.5 text-sm">
                                <option value="all">All Locations</option>
                                <option value="IN">India</option>
                                <option value="GL">Global</option>
                            </select>
                            <div className="flex gap-1">
                                {BUCKETS.filter(b => b.key !== 'exclude').map(b => (
                                    <button key={b.key} onClick={() => setBucketFilters(prev => prev.includes(b.key) ? prev.filter(x => x !== b.key) : [...prev, b.key])}
                                        className={`px-2 py-1 rounded text-xs border ${bucketFilters.includes(b.key) ? b.color + ' border-current' : 'bg-gray-50 text-gray-400'}`}>{b.label}</button>
                                ))}
                            </div>
                            <div className="flex items-center gap-2">
                                <span className="text-xs text-gray-500">Vol‚â•</span>
                                <input type="number" value={minVolume} onChange={e => setMinVolume(+e.target.value)} className="border rounded px-2 py-1 text-sm w-16" />
                                <span className="text-xs text-gray-500">Pos‚â§</span>
                                <input type="number" value={maxPosition} onChange={e => setMaxPosition(+e.target.value)} className="border rounded px-2 py-1 text-sm w-16" />
                            </div>
                            <span className="text-xs text-gray-400 ml-auto">{filteredKeywords.length} shown</span>
                        </div>

                        {/* Bulk actions */}
                        {selectedRows.size > 0 && (
                            <div className="px-4 py-2 bg-indigo-50 border-b flex items-center gap-3">
                                <span className="text-sm font-medium text-indigo-700">{selectedRows.size} selected</span>
                                <select onChange={e => { if (e.target.value) handleBucketOverride(Array.from(selectedRows), e.target.value); e.target.value = ''; }} className="border rounded px-2 py-1 text-sm">
                                    <option value="">Change bucket‚Ä¶</option>
                                    {BUCKETS.map(b => <option key={b.key} value={b.key}>{b.label}</option>)}
                                </select>
                                <button onClick={() => handleExclude(Array.from(selectedRows))} className="px-2 py-1 bg-red-100 text-red-700 rounded text-sm">Exclude</button>
                                <button onClick={() => handleResetOverrides(Array.from(selectedRows))} className="px-2 py-1 bg-gray-100 text-gray-700 rounded text-sm">Reset</button>
                                <button onClick={() => setSelectedRows(new Set())} className="ml-auto text-xs text-gray-500">Clear</button>
                            </div>
                        )}

                        {/* Table */}
                        <div className="max-h-[500px] overflow-y-auto">
                            <table className="w-full text-sm">
                                <thead className="bg-gray-50 sticky top-0"><tr>
                                    <th className="px-4 py-2 w-8"><input type="checkbox" checked={selectedRows.size === sortedKeywords.length && sortedKeywords.length > 0} onChange={e => setSelectedRows(e.target.checked ? new Set(sortedKeywords.map(k => k.id)) : new Set())} /></th>
                                    <th onClick={() => { setSortField('keyword'); setSortDir(sortField === 'keyword' && sortDir === 'asc' ? 'desc' : 'asc'); }} className="text-left px-4 py-2 cursor-pointer hover:bg-gray-100">
                                        Keyword {sortField === 'keyword' && (sortDir === 'asc' ? '‚Üë' : '‚Üì')}
                                    </th>
                                    <th onClick={() => { setSortField('volume'); setSortDir(sortField === 'volume' && sortDir === 'desc' ? 'asc' : 'desc'); }} className="text-right px-3 py-2 cursor-pointer hover:bg-gray-100">
                                        Vol {sortField === 'volume' && (sortDir === 'asc' ? '‚Üë' : '‚Üì')}
                                    </th>
                                    <th onClick={() => { setSortField('position'); setSortDir(sortField === 'position' && sortDir === 'asc' ? 'desc' : 'asc'); }} className="text-right px-3 py-2 cursor-pointer hover:bg-gray-100">
                                        Pos {sortField === 'position' && (sortDir === 'asc' ? '‚Üë' : '‚Üì')}
                                    </th>
                                    <th className="text-center px-3 py-2">Loc</th>
                                    <th onClick={() => { setSortField('bucket'); setSortDir(sortField === 'bucket' && sortDir === 'asc' ? 'desc' : 'asc'); }} className="text-center px-3 py-2 cursor-pointer hover:bg-gray-100">
                                        Bucket {sortField === 'bucket' && (sortDir === 'asc' ? '‚Üë' : '‚Üì')}
                                    </th>
                                    <th className="text-center px-3 py-2">Actions</th>
                                </tr></thead>
                                <tbody className="divide-y">
                                    {sortedKeywords.slice(0, 200).map(k => (
                                        <tr key={k.id} className={`hover:bg-gray-50 ${k.isOverridden ? 'bg-amber-50' : ''}`}>
                                            <td className="px-4 py-2"><input type="checkbox" checked={selectedRows.has(k.id)} onChange={e => setSelectedRows(prev => { const n = new Set(prev); e.target.checked ? n.add(k.id) : n.delete(k.id); return n; })} /></td>
                                            <td className="px-4 py-2 font-medium">
                                                {k.keyword}
                                                {k.isOverridden && <span className="ml-1 text-xs text-amber-600">‚úé</span>}
                                            </td>
                                            <td className="px-3 py-2 text-right">{k.volume.toLocaleString()}</td>
                                            <td className="px-3 py-2 text-right">{k.position || '-'}</td>
                                            <td className="px-3 py-2 text-center text-xs">{k.locationCode}</td>
                                            <td className="px-3 py-2 text-center"><BucketBadge bucket={k.effectiveBucket} /></td>
                                            <td className="px-3 py-2 text-center">
                                                <select value="" onChange={e => { if (e.target.value === 'reset') handleResetOverrides([k.id]); else if (e.target.value) handleBucketOverride([k.id], e.target.value); }} className="text-xs border rounded px-1 py-0.5">
                                                    <option value="">‚Ä¶</option>
                                                    {BUCKETS.map(b => <option key={b.key} value={b.key}>{b.label}</option>)}
                                                    {k.isOverridden && <option value="reset">‚Ü© Reset</option>}
                                                </select>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>

                        {/* Generate button */}
                        <div className="p-4 border-t bg-gray-50">
                            {clusters.length > 0 ? (
                                <div className="flex items-center gap-3">
                                    <span className="text-sm text-green-700 font-medium">‚úì {clusters.length} clusters generated with {stats?.clusteredKeywords || 0} keywords</span>
                                    <button onClick={() => setMainTab('clusters')} className="px-3 py-1.5 bg-purple-600 text-white rounded text-sm">View Topic Clusters ‚Üí</button>
                                    <button onClick={() => { if (confirm('Reset clusters and regenerate fresh?')) { setClusters([]); setUnclustered([]); setStats(null); setManuallyAdded({}); setDraftChanges(0); localStorage.removeItem('cluster-studio-draft'); } }} className="px-3 py-1.5 border border-red-300 text-red-600 rounded text-sm">üîÑ Reset & Regenerate</button>
                                </div>
                            ) : (
                                <button onClick={handleGenerateClusters} disabled={!clusteringKeywords.length || clustering} className="px-4 py-2 bg-purple-600 text-white rounded-lg font-bold hover:bg-purple-700 disabled:opacity-50 flex items-center gap-2">
                                    {clustering ? '‚è≥ Clustering‚Ä¶' : <>üß† Generate Topic Clusters (TF-IDF) <span className="bg-purple-500 px-2 py-0.5 rounded text-xs">{clusteringKeywords.length}</span></>}
                                </button>
                            )}
                        </div>
                    </div>
                )}

                {/* Tab 2: Topic Clusters */}
                {mainTab === 'clusters' && (
                    <div className="space-y-4">
                        {/* Controls */}
                        <div className="bg-white rounded-xl shadow-sm border p-4">
                            <div className="grid lg:grid-cols-2 gap-4">
                                <div className="space-y-3">
                                    <div><label className="text-xs font-medium text-gray-700">Scope</label>
                                        <select value={scope} onChange={e => setScope(e.target.value as ClusteringScope)} className="w-full border rounded px-3 py-2 text-sm mt-1">
                                            <option value="include-both">Include buckets (Buy + Learn)</option>
                                            <option value="include-buy">Include | Buy only</option>
                                            <option value="include-learn">Include | Learn only</option>
                                            <option value="brand-nav">Brand | Nav only</option>
                                        </select>
                                    </div>
                                    <div><label className="text-xs font-medium text-gray-700">Policy</label>
                                        <div className="flex gap-2 mt-1">
                                            <button onClick={() => setPolicy('topic')} className={`flex-1 px-3 py-2 rounded text-xs border ${policy === 'topic' ? 'bg-indigo-100 text-indigo-700 border-indigo-300' : 'bg-white'}`}>Topic (default)</button>
                                            <button onClick={() => setPolicy('bucket-separated')} className={`flex-1 px-3 py-2 rounded text-xs border ${policy === 'bucket-separated' ? 'bg-amber-100 text-amber-700 border-amber-300' : 'bg-white'}`}>Bucket-separated</button>
                                        </div>
                                    </div>
                                </div>
                                <div className="space-y-3">
                                    <div><label className="text-xs font-medium text-gray-700">Granularity: {granularity}%</label>
                                        <input type="range" min={0} max={100} value={granularity} onChange={e => setGranularity(+e.target.value)} className="w-full mt-1" title="Higher = more clusters" />
                                        <div className="flex justify-between text-[10px] text-gray-400"><span>Broad</span><span>Balanced</span><span>Detailed</span></div>
                                    </div>
                                    <div className="flex gap-4">
                                        <div className="flex-1"><label className="text-xs font-medium text-gray-700">Min Size</label>
                                            <input type="number" min={2} max={20} value={minClusterSize} onChange={e => setMinClusterSize(+e.target.value)} className="w-full border rounded px-3 py-2 text-sm mt-1" />
                                        </div>
                                        <div className="flex-1 flex flex-col gap-2">
                                            {clusters.length > 0 ? (
                                                <div className="flex items-center gap-2">
                                                    <span className="text-xs text-green-600 font-medium">‚úì Clusters ready</span>
                                                    <button onClick={() => { if (confirm('Reset and regenerate?')) { setClusters([]); setUnclustered([]); setStats(null); setManuallyAdded({}); setDraftChanges(0); localStorage.removeItem('cluster-studio-draft'); } }} className="px-2 py-1 border border-red-300 text-red-600 rounded text-xs">Reset</button>
                                                </div>
                                            ) : (
                                                <button onClick={handleGenerateClusters} disabled={clustering} className="w-full px-4 py-2 bg-purple-600 text-white rounded-lg font-bold disabled:opacity-50">
                                                    {clustering ? '‚è≥' : 'üß†'} Generate ({clusteringKeywords.length})
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* Quality Summary - computed from current state */}
                        {(clusters.length > 0 || unclustered.length > 0) && (
                            <div className="bg-gradient-to-r from-indigo-50 to-purple-50 rounded-xl border border-indigo-100 p-4">
                                <div className="grid grid-cols-5 gap-3 text-center">
                                    <div className="bg-white rounded p-3 border" title="Total keywords in clusters + unclustered">
                                        <div className="text-2xl font-bold">{clusters.reduce((s, c) => s + c.size, 0) + unclustered.length}</div>
                                        <div className="text-xs text-gray-500">Considered</div>
                                    </div>
                                    <div className="bg-white rounded p-3 border" title="Number of topic clusters">
                                        <div className="text-2xl font-bold text-purple-600">{clusters.length}</div>
                                        <div className="text-xs text-gray-500">Clusters</div>
                                    </div>
                                    <div className="bg-white rounded p-3 border" title="Keywords assigned to clusters">
                                        <div className="text-2xl font-bold text-green-600">{clusters.reduce((s, c) => s + c.size, 0)}</div>
                                        <div className="text-xs text-gray-500">Clustered</div>
                                    </div>
                                    <div className="bg-white rounded p-3 border" title="Keywords not yet assigned to any cluster">
                                        <div className="text-2xl font-bold text-amber-600">{unclustered.length}</div>
                                        <div className="text-xs text-gray-500">Unclustered</div>
                                    </div>
                                    <div className="bg-white rounded p-3 border" title="Percentage of keywords not in clusters">
                                        <div className="text-2xl font-bold text-red-600">
                                            {clusters.reduce((s, c) => s + c.size, 0) + unclustered.length > 0
                                                ? Math.round(unclustered.length / (clusters.reduce((s, c) => s + c.size, 0) + unclustered.length) * 100)
                                                : 0}%
                                        </div>
                                        <div className="text-xs text-gray-500">Unclustered %</div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Save bar */}
                        {clusters.length > 0 && (
                            <div className="bg-white rounded-xl shadow-sm border p-3 flex items-center justify-between">
                                <span className="text-sm text-gray-600" title="Number of manual changes since last save">{draftChanges > 0 ? `Unsaved changes: ${draftChanges}` : 'No unsaved changes'}</span>
                                <div className="flex gap-2">
                                    <button
                                        onClick={() => { if (confirm('Clear all draft clusters? This cannot be undone.')) { setClusters([]); setUnclustered([]); setStats(null); setManuallyAdded({}); setDraftChanges(0); localStorage.removeItem('cluster-studio-draft'); setMainTab('keywords'); } }}
                                        className="px-3 py-1.5 border border-red-300 text-red-600 rounded text-sm"
                                        title="Delete all draft clusters and start fresh. This will NOT affect saved Final Clusters."
                                    >
                                        üóë Clear Draft
                                    </button>
                                    <button
                                        onClick={handleSave}
                                        className="px-4 py-1.5 bg-green-600 text-white rounded text-sm font-medium"
                                        title="Save current clusters to Final Clusters. This REPLACES any previously saved clusters completely."
                                    >
                                        üíæ Save Clustering (Replaces Final)
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* Main layout */}
                        <div className="grid lg:grid-cols-3 gap-4">
                            {/* Clusters list */}
                            <div className="bg-white rounded-xl shadow-sm border overflow-hidden">
                                <div className="px-4 py-3 border-b bg-gray-50">
                                    <div className="flex items-center justify-between mb-2">
                                        <span className="font-bold">üîÆ Clusters ({clusters.length})</span>
                                        {Object.values(manuallyAdded).reduce((a, b) => a + b, 0) > 0 && (
                                            <span className="text-xs bg-green-100 text-green-700 px-2 py-0.5 rounded-full">
                                                +{Object.values(manuallyAdded).reduce((a, b) => a + b, 0)} added
                                            </span>
                                        )}
                                    </div>
                                    <input
                                        type="text"
                                        placeholder="Search clusters‚Ä¶"
                                        value={clusterListSearch}
                                        onChange={e => setClusterListSearch(e.target.value)}
                                        className="w-full border rounded px-2 py-1 text-sm"
                                    />
                                </div>
                                <div className="max-h-[450px] overflow-y-auto divide-y">
                                    {clusters.filter(c => c.label.toLowerCase().includes(clusterListSearch.toLowerCase())).length === 0 ? (
                                        <div className="p-6 text-center text-gray-500 text-sm">
                                            {clusters.length === 0 ? 'Generate clusters to see results' : 'No clusters match search'}
                                        </div>
                                    ) : clusters.filter(c => c.label.toLowerCase().includes(clusterListSearch.toLowerCase())).map(c => (
                                        <div key={c.id} onClick={() => setDrawerCluster(c)} className={`p-3 hover:bg-gray-50 cursor-pointer ${manuallyAdded[c.id] ? 'border-l-4 border-green-500' : ''}`}>
                                            <div className="flex items-center justify-between mb-1">
                                                <span className="font-medium text-sm">{c.label}</span>
                                                <div className="flex items-center gap-1">
                                                    {manuallyAdded[c.id] && (
                                                        <span className="px-1.5 py-0.5 bg-green-100 text-green-700 rounded text-[10px] font-bold">+{manuallyAdded[c.id]}</span>
                                                    )}
                                                    <span className="px-2 py-0.5 bg-purple-100 text-purple-700 rounded text-xs font-bold">{c.size}</span>
                                                </div>
                                            </div>
                                            <div className="flex items-center gap-2 text-xs text-gray-500">
                                                <span>{c.totalVolume.toLocaleString()} vol</span>
                                                <span className={`px-1 py-0.5 rounded ${ORIGIN_LABELS[c.origin]?.color}`} title={ORIGIN_LABELS[c.origin]?.tooltip}>{ORIGIN_LABELS[c.origin]?.label}</span>
                                                <OpportunityBadge score={c.opportunityScore} />
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>

                            {/* Keywords + Unclustered */}
                            <div className="lg:col-span-2 bg-white rounded-xl shadow-sm border overflow-hidden">
                                <div className="px-4 py-3 border-b bg-gray-50 flex items-center justify-between">
                                    <span className="font-bold">üìù Keywords</span>
                                    <div className="flex gap-1 bg-gray-100 p-0.5 rounded">
                                        {(['all', 'clustered', 'unclustered'] as const).map(t => (
                                            <button key={t} onClick={() => setClusterSubTab(t)} className={`px-3 py-1 rounded text-xs font-medium ${clusterSubTab === t ? 'bg-white text-indigo-700 shadow-sm' : 'text-gray-600'}`}>
                                                {t === 'all' ? `All (${stats?.keywordsConsidered || 0})` : t === 'clustered' ? `Clustered (${stats?.clusteredKeywords || 0})` : `Unclustered (${unclustered.length})`}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                <div className="max-h-[500px] overflow-y-auto">
                                    {clusterSubTab === 'unclustered' ? (
                                        <>
                                            {/* Filter and bulk actions */}
                                            <div className="p-3 border-b bg-gray-50 space-y-2">
                                                <div className="flex gap-2">
                                                    <input
                                                        type="text"
                                                        placeholder="Filter keywords‚Ä¶"
                                                        value={unclusteredFilter}
                                                        onChange={e => setUnclusteredFilter(e.target.value)}
                                                        className="flex-1 border rounded px-3 py-1.5 text-sm"
                                                    />
                                                    <select
                                                        value={unclusteredReasonFilter}
                                                        onChange={e => setUnclusteredReasonFilter(e.target.value)}
                                                        className="border rounded px-2 py-1.5 text-sm bg-white"
                                                    >
                                                        <option value="all">All Reasons</option>
                                                        <option value="below_min_cluster_size">Below Min Size (can group)</option>
                                                        <option value="insufficient_similarity">Low Similarity</option>
                                                        <option value="empty_after_normalization">Empty Normalized</option>
                                                        <option value="excluded">Excluded</option>
                                                    </select>
                                                </div>
                                                {selectedUnclustered.size > 0 && (
                                                    <div className="flex items-center gap-2 flex-wrap">
                                                        <span className="text-sm font-medium text-indigo-700">{selectedUnclustered.size} selected</span>
                                                        <div className="relative flex-1 max-w-xs">
                                                            <input
                                                                type="text"
                                                                placeholder="Search clusters to add to‚Ä¶"
                                                                value={clusterSearch}
                                                                onChange={e => { setClusterSearch(e.target.value); setShowClusterDropdown(true); }}
                                                                onFocus={() => setShowClusterDropdown(true)}
                                                                className="w-full border rounded px-3 py-1.5 text-sm"
                                                            />
                                                            {showClusterDropdown && (
                                                                <>
                                                                    {/* Backdrop to close dropdown */}
                                                                    <div
                                                                        className="fixed inset-0 z-40"
                                                                        onClick={() => setShowClusterDropdown(false)}
                                                                    />
                                                                    <div className="absolute z-50 left-0 w-72 top-full mt-1 bg-white border rounded-lg shadow-xl max-h-64 overflow-y-auto">
                                                                        {clusters
                                                                            .filter(c => c.label.toLowerCase().includes(clusterSearch.toLowerCase()))
                                                                            .slice(0, 20)
                                                                            .map(c => (
                                                                                <button
                                                                                    key={c.id}
                                                                                    onClick={(e) => {
                                                                                        e.stopPropagation();
                                                                                        const count = selectedUnclustered.size;
                                                                                        const clusterName = c.label;
                                                                                        Array.from(selectedUnclustered).forEach(kw => addToCluster(kw, c.id));
                                                                                        setSelectedUnclustered(new Set());
                                                                                        setClusterSearch('');
                                                                                        setShowClusterDropdown(false);
                                                                                        setUnclusteredFilter('');
                                                                                        setNotification({ type: 'success', msg: `‚úì Added ${count} keywords to "${clusterName}"` });
                                                                                        setTimeout(() => setNotification(null), 4000);
                                                                                    }}
                                                                                    className="w-full text-left px-3 py-2 hover:bg-indigo-50 text-sm flex items-center justify-between border-b last:border-b-0"
                                                                                >
                                                                                    <span className="font-medium">{c.label}</span>
                                                                                    <span className="text-xs text-gray-400 bg-gray-100 px-2 py-0.5 rounded">{c.size} kws</span>
                                                                                </button>
                                                                            ))}
                                                                        {clusters.filter(c => c.label.toLowerCase().includes(clusterSearch.toLowerCase())).length === 0 && (
                                                                            <div className="px-3 py-2 text-sm text-gray-500">No clusters match</div>
                                                                        )}
                                                                    </div>
                                                                </>
                                                            )}
                                                        </div>
                                                        <button
                                                            onClick={() => { createClusterFromUnclustered(Array.from(selectedUnclustered)); setSelectedUnclustered(new Set()); }}
                                                            className="px-3 py-1.5 bg-indigo-600 text-white text-sm rounded"
                                                            title="Create a new cluster from selected keywords. The cluster name will be based on the first keyword."
                                                        >
                                                            + New Cluster
                                                        </button>
                                                        <button
                                                            onClick={() => { Array.from(selectedUnclustered).forEach(kw => excludeUnclustered(kw)); setSelectedUnclustered(new Set()); }}
                                                            className="px-3 py-1.5 bg-red-100 text-red-700 text-sm rounded"
                                                            title="Mark selected keywords as excluded. They won't appear in clusters."
                                                        >
                                                            Exclude
                                                        </button>
                                                        <button
                                                            onClick={() => setSelectedUnclustered(new Set())}
                                                            className="text-xs text-gray-500"
                                                            title="Deselect all selected keywords"
                                                        >
                                                            Clear
                                                        </button>
                                                    </div>
                                                )}
                                            </div>

                                            {unclustered.filter(u => u.keyword.toLowerCase().includes(unclusteredFilter.toLowerCase()) && (unclusteredReasonFilter === 'all' || u.reason === unclusteredReasonFilter)).length === 0 ? (
                                                <div className="p-6 text-center">
                                                    <div className="text-gray-500 text-sm mb-2">
                                                        {unclustered.length === 0
                                                            ? 'No unclustered keywords remaining! üéâ'
                                                            : `No unclustered keywords matching "${unclusteredFilter}"`
                                                        }
                                                    </div>
                                                    {unclusteredFilter && (
                                                        <button
                                                            onClick={() => setUnclusteredFilter('')}
                                                            className="px-3 py-1.5 bg-indigo-100 text-indigo-700 rounded text-sm"
                                                        >
                                                            Clear filter to see all {unclustered.length} unclustered
                                                        </button>
                                                    )}
                                                    {unclusteredReasonFilter !== 'all' && (
                                                        <button
                                                            onClick={() => setUnclusteredReasonFilter('all')}
                                                            className="px-3 py-1.5 bg-amber-100 text-amber-700 rounded text-sm"
                                                        >
                                                            Show all reasons
                                                        </button>
                                                    )}
                                                </div>
                                            ) : (
                                                <table className="w-full text-sm">
                                                    <thead className="bg-gray-50 sticky top-0"><tr>
                                                        <th className="px-3 py-2 w-8">
                                                            <input
                                                                type="checkbox"
                                                                checked={selectedUnclustered.size === unclustered.filter(u => u.keyword.toLowerCase().includes(unclusteredFilter.toLowerCase()) && (unclusteredReasonFilter === 'all' || u.reason === unclusteredReasonFilter)).length && unclustered.length > 0}
                                                                onChange={e => setSelectedUnclustered(e.target.checked ? new Set(unclustered.filter(u => u.keyword.toLowerCase().includes(unclusteredFilter.toLowerCase()) && (unclusteredReasonFilter === 'all' || u.reason === unclusteredReasonFilter)).map(u => u.keyword)) : new Set())}
                                                            />
                                                        </th>
                                                        <th className="text-left px-4 py-2 cursor-pointer hover:bg-gray-100" onClick={() => { if (unclusteredSort === 'keyword') setUnclusteredSortDir(d => d === 'asc' ? 'desc' : 'asc'); else { setUnclusteredSort('keyword'); setUnclusteredSortDir('asc'); } }}>
                                                            Keyword {unclusteredSort === 'keyword' && (unclusteredSortDir === 'asc' ? '‚Üë' : '‚Üì')}
                                                        </th>
                                                        <th className="text-right px-3 py-2 cursor-pointer hover:bg-gray-100" onClick={() => { if (unclusteredSort === 'volume') setUnclusteredSortDir(d => d === 'asc' ? 'desc' : 'asc'); else { setUnclusteredSort('volume'); setUnclusteredSortDir('desc'); } }}>
                                                            Vol {unclusteredSort === 'volume' && (unclusteredSortDir === 'asc' ? '‚Üë' : '‚Üì')}
                                                        </th>
                                                        <th className="text-center px-3 py-2 cursor-pointer hover:bg-gray-100" onClick={() => { if (unclusteredSort === 'bucket') setUnclusteredSortDir(d => d === 'asc' ? 'desc' : 'asc'); else { setUnclusteredSort('bucket'); setUnclusteredSortDir('asc'); } }}>
                                                            Bucket {unclusteredSort === 'bucket' && (unclusteredSortDir === 'asc' ? '‚Üë' : '‚Üì')}
                                                        </th>
                                                        <th className="text-left px-3 py-2 cursor-pointer hover:bg-gray-100" onClick={() => { if (unclusteredSort === 'reason') setUnclusteredSortDir(d => d === 'asc' ? 'desc' : 'asc'); else { setUnclusteredSort('reason'); setUnclusteredSortDir('asc'); } }}>
                                                            Reason {unclusteredSort === 'reason' && (unclusteredSortDir === 'asc' ? '‚Üë' : '‚Üì')}
                                                        </th>
                                                    </tr></thead>
                                                    <tbody className="divide-y">
                                                        {unclustered
                                                            .filter(u => u.keyword.toLowerCase().includes(unclusteredFilter.toLowerCase()) && (unclusteredReasonFilter === 'all' || u.reason === unclusteredReasonFilter))
                                                            .sort((a, b) => {
                                                                const mult = unclusteredSortDir === 'asc' ? 1 : -1;
                                                                if (unclusteredSort === 'keyword') return mult * a.keyword.localeCompare(b.keyword);
                                                                if (unclusteredSort === 'volume') return mult * (a.volume - b.volume);
                                                                if (unclusteredSort === 'bucket') return mult * a.bucket.localeCompare(b.bucket);
                                                                return mult * a.reason.localeCompare(b.reason);
                                                            })
                                                            .map((u, i) => (
                                                                <tr key={i} className={`hover:bg-gray-50 ${selectedUnclustered.has(u.keyword) ? 'bg-indigo-50' : ''}`}>
                                                                    <td className="px-3 py-2">
                                                                        <input
                                                                            type="checkbox"
                                                                            checked={selectedUnclustered.has(u.keyword)}
                                                                            onChange={e => setSelectedUnclustered(prev => { const n = new Set(prev); e.target.checked ? n.add(u.keyword) : n.delete(u.keyword); return n; })}
                                                                        />
                                                                    </td>
                                                                    <td className="px-4 py-2 font-medium">{u.keyword}</td>
                                                                    <td className="px-3 py-2 text-right">{u.volume.toLocaleString()}</td>
                                                                    <td className="px-3 py-2 text-center"><BucketBadge bucket={u.bucket} /></td>
                                                                    <td className="px-3 py-2">
                                                                        <span className={`text-xs px-1.5 py-0.5 rounded ${u.reason === 'below_min_cluster_size' ? 'bg-amber-100 text-amber-700' :
                                                                            u.reason === 'insufficient_similarity' ? 'bg-red-100 text-red-700' :
                                                                                u.reason === 'empty_after_normalization' ? 'bg-gray-100 text-gray-600' :
                                                                                    'bg-blue-100 text-blue-700'
                                                                            }`} title={{
                                                                                'below_min_cluster_size': 'Cluster was too small (< min size)',
                                                                                'insufficient_similarity': 'Not similar enough to any existing cluster',
                                                                                'empty_after_normalization': 'Keyword became empty after removing geo/commercial terms',
                                                                                'manual_removed': 'Manually removed from a cluster'
                                                                            }[u.reason] || u.reason}>
                                                                            {u.reason.replace(/_/g, ' ')}
                                                                        </span>
                                                                    </td>
                                                                </tr>
                                                            ))}
                                                    </tbody>
                                                </table>
                                            )}
                                        </>
                                    ) : (
                                        <div className="p-6 text-center text-gray-500 text-sm">
                                            {clusterSubTab === 'all' ? `${stats?.keywordsConsidered || 0} keywords processed` : `${stats?.clusteredKeywords || 0} keywords in clusters`}
                                            <br /><span className="text-xs">Open a cluster to see its keywords</span>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>
                )}

                {/* Tab 3: Final Clusters */}
                {mainTab === 'final' && (
                    <div className="space-y-4">
                        {!hasSaved ? (
                            <div className="bg-white rounded-xl shadow-sm border p-8 text-center">
                                <div className="text-5xl mb-4">‚úÖ</div>
                                <h3 className="text-lg font-bold mb-2">No Saved Clusters Yet</h3>
                                <p className="text-gray-500 mb-4">Generate and save clusters from the Topic Clusters tab</p>
                                <button onClick={() => setMainTab('clusters')} className="px-4 py-2 bg-purple-600 text-white rounded-lg">Go to Topic Clusters</button>
                            </div>
                        ) : (
                            <>
                                <div className="bg-green-50 border border-green-200 rounded-xl p-4 flex items-center justify-between">
                                    <div>
                                        <span className="font-bold text-green-800">‚úÖ Ready for Intent Classification</span>
                                        <p className="text-sm text-green-700">{savedClusters.length} clusters saved with {savedClusters.reduce((s, c) => s + c.size, 0)} keywords</p>
                                    </div>
                                    <button onClick={() => exportCSV(savedClusters, `final-clusters-${clientCode}.csv`)} className="px-4 py-2 bg-green-600 text-white rounded-lg">Export CSV</button>
                                </div>

                                {/* Opportunity Formula */}
                                <div className="bg-gradient-to-r from-purple-50 to-indigo-50 border border-purple-100 rounded-xl p-4">
                                    <h4 className="font-bold text-purple-800 mb-2">üìä Opportunity Score Formula</h4>
                                    <div className="text-sm text-purple-700 font-mono bg-white/50 px-3 py-2 rounded border border-purple-200">
                                        Score = <span className="text-green-700">35% √ó Demand</span> + <span className="text-blue-700">35% √ó Visibility Gap</span> + <span className="text-amber-700">20% √ó Coverage</span> + <span className="text-red-700">10% √ó Commercial</span>
                                    </div>
                                    <div className="grid grid-cols-4 gap-2 mt-3 text-xs">
                                        <div className="bg-white rounded p-2 border"><strong className="text-green-700">Demand:</strong> Based on total volume percentile</div>
                                        <div className="bg-white rounded p-2 border"><strong className="text-blue-700">Visibility:</strong> Higher avg position = more room to grow</div>
                                        <div className="bg-white rounded p-2 border"><strong className="text-amber-700">Coverage:</strong> Number of keywords in cluster</div>
                                        <div className="bg-white rounded p-2 border"><strong className="text-red-700">Commercial:</strong> % of "Buy" intent keywords</div>
                                    </div>
                                </div>

                                {/* Search and Sort */}
                                <div className="bg-white rounded-xl shadow-sm border">
                                    <div className="px-4 py-3 border-b bg-gray-50 flex items-center justify-between gap-4">
                                        <input
                                            type="text"
                                            placeholder="Search clusters‚Ä¶"
                                            value={finalClusterSearch}
                                            onChange={e => setFinalClusterSearch(e.target.value)}
                                            className="flex-1 border rounded px-3 py-1.5 text-sm"
                                            title="Search clusters by name"
                                        />
                                        <select
                                            value={finalClusterOriginFilter}
                                            onChange={e => setFinalClusterOriginFilter(e.target.value as any)}
                                            className="border rounded px-2 py-1.5 text-sm bg-white"
                                            title="Filter by cluster origin: Auto (TF-IDF generated), Manual (user created), Hybrid (auto + manual edits)"
                                        >
                                            <option value="all">All Origins</option>
                                            <option value="manual">Manual (Created by you)</option>
                                            <option value="hybrid">Hybrid (Auto + edits)</option>
                                            <option value="auto">Auto (TF-IDF only)</option>
                                        </select>
                                        <div className="flex items-center gap-2 text-xs">
                                            <span className="text-gray-500">Sort by:</span>
                                            {(['opportunity', 'volume', 'size'] as const).map(s => (
                                                <button
                                                    key={s}
                                                    onClick={() => {
                                                        if (finalClusterSort === s) setFinalClusterSortDir(d => d === 'asc' ? 'desc' : 'asc');
                                                        else { setFinalClusterSort(s); setFinalClusterSortDir('desc'); }
                                                    }}
                                                    className={`px-2 py-1 rounded ${finalClusterSort === s ? 'bg-indigo-100 text-indigo-700' : 'bg-gray-100'}`}
                                                >
                                                    {s === 'opportunity' ? 'Score' : s === 'volume' ? 'Volume' : 'Size'}
                                                    {finalClusterSort === s && (finalClusterSortDir === 'desc' ? ' ‚Üì' : ' ‚Üë')}
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                    <div className="divide-y max-h-[600px] overflow-y-auto">
                                        {savedClusters
                                            .filter(c => c.label.toLowerCase().includes(finalClusterSearch.toLowerCase()) && (finalClusterOriginFilter === 'all' || c.origin === finalClusterOriginFilter))
                                            .sort((a, b) => {
                                                const mult = finalClusterSortDir === 'desc' ? -1 : 1;
                                                if (finalClusterSort === 'opportunity') return mult * (a.opportunityScore - b.opportunityScore);
                                                if (finalClusterSort === 'volume') return mult * (a.totalVolume - b.totalVolume);
                                                return mult * (a.size - b.size);
                                            })
                                            .map(c => (
                                                <div key={c.id} className="hover:bg-gray-50">
                                                    <div
                                                        onClick={() => setExpandedFinalCluster(expandedFinalCluster === c.id ? null : c.id)}
                                                        className="p-4 cursor-pointer flex items-start justify-between"
                                                    >
                                                        <div className="flex-1">
                                                            <div className="flex items-center gap-2 mb-1">
                                                                <span className="font-medium">{c.label}</span>
                                                                <span className={`px-1.5 py-0.5 rounded text-xs ${ORIGIN_LABELS[c.origin]?.color}`} title={ORIGIN_LABELS[c.origin]?.tooltip}>{ORIGIN_LABELS[c.origin]?.label}</span>
                                                                <span className="px-2 py-0.5 bg-purple-100 text-purple-700 rounded text-xs font-bold">{c.size} kws</span>
                                                            </div>
                                                            <div className="text-sm text-gray-500">
                                                                {c.totalVolume.toLocaleString()} combined volume ‚Ä¢ Avg pos: {c.avgPosition.toFixed(1)}
                                                            </div>
                                                            <div className="text-xs text-gray-400 mt-1 truncate max-w-lg">
                                                                {c.keywords.slice(0, 5).map(k => k.keyword).join(', ')}{c.keywords.length > 5 && ` +${c.keywords.length - 5} more`}
                                                            </div>
                                                        </div>
                                                        <div className="flex items-center gap-3">
                                                            <div className="text-right">
                                                                <OpportunityBadge score={c.opportunityScore} />
                                                                <div className="text-[10px] text-gray-400 mt-1" title="Demand | Visibility Gap | Coverage | Commercial">
                                                                    Dem:{c.opportunityBreakdown.demand} Gap:{c.opportunityBreakdown.visibility} Cov:{c.opportunityBreakdown.coverage} Com:{c.opportunityBreakdown.commercial}
                                                                </div>
                                                            </div>
                                                            <span className="text-gray-400">{expandedFinalCluster === c.id ? '‚ñº' : '‚ñ∂'}</span>
                                                        </div>
                                                    </div>
                                                    {expandedFinalCluster === c.id && (
                                                        <div className="px-4 pb-4">
                                                            <div className="bg-gray-50 rounded-lg p-3">
                                                                <div className="text-xs font-medium text-gray-600 mb-2">All Keywords ({c.keywords.length})</div>
                                                                <div className="flex flex-wrap gap-1">
                                                                    {c.keywords.sort((a, b) => b.volume - a.volume).map((k, i) => (
                                                                        <span key={i} className="px-2 py-1 bg-white border rounded text-xs">
                                                                            {k.keyword} <span className="text-gray-400">({k.volume.toLocaleString()})</span>
                                                                        </span>
                                                                    ))}
                                                                </div>
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>
                                            ))}
                                    </div>
                                </div>
                            </>
                        )}
                    </div>
                )}

                {/* Tab 4: Intent Classification */}
                {mainTab === 'intent' && (
                    <div className="space-y-4">
                        {/* Header with Action Buttons */}
                        <div className="bg-white rounded-xl shadow-sm border p-4">
                            <div className="flex items-center justify-between">
                                <div>
                                    <h2 className="font-bold text-lg">üéØ Intent Classification</h2>
                                    <p className="text-sm text-gray-500">
                                        {intentResults
                                            ? `Last run: ${new Date(intentResults.timestamp).toLocaleString()} ‚Ä¢ ${intentResults.clusters.length} clusters classified`
                                            : 'Classify your saved clusters by search intent'}
                                    </p>
                                </div>
                                <div className="flex gap-2">
                                    <button
                                        onClick={async () => {
                                            if (savedClusters.length === 0) {
                                                setNotification({ type: 'error', msg: 'No saved clusters. Save clusters first in Final Clusters tab.' });
                                                return;
                                            }
                                            setIntentLoading(true);
                                            try {
                                                const res = await fetch('/api/intent/classify', {
                                                    method: 'POST',
                                                    headers: { 'Content-Type': 'application/json' },
                                                    body: JSON.stringify({
                                                        clientCode,
                                                        clusters: savedClusters,
                                                        brandList: [],
                                                        mode: 'rule_only'
                                                    })
                                                });
                                                const data = await res.json();
                                                if (data.success) {
                                                    setIntentResults(data.data);
                                                    setNotification({ type: 'success', msg: `Classified ${data.stats.totalClusters} clusters (${data.stats.lowConfidence} low confidence)` });
                                                } else {
                                                    setNotification({ type: 'error', msg: data.error });
                                                }
                                            } catch (err) {
                                                setNotification({ type: 'error', msg: 'Classification failed' });
                                            }
                                            setIntentLoading(false);
                                        }}
                                        disabled={intentLoading || savedClusters.length === 0}
                                        className="px-4 py-2 bg-indigo-600 text-white rounded-lg font-medium disabled:opacity-50"
                                        title="Run rule-based classification on all saved clusters"
                                    >
                                        {intentLoading ? '‚è≥ Classifying...' : 'üîç Run Classification (Rules)'}
                                    </button>
                                    <button
                                        onClick={async () => {
                                            if (savedClusters.length === 0) {
                                                setNotification({ type: 'error', msg: 'No saved clusters.' });
                                                return;
                                            }
                                            setIntentLoading(true);
                                            try {
                                                const res = await fetch('/api/intent/classify', {
                                                    method: 'POST',
                                                    headers: { 'Content-Type': 'application/json' },
                                                    body: JSON.stringify({
                                                        clientCode,
                                                        clusters: savedClusters,
                                                        brandList: [],
                                                        mode: 'rule_plus_llm'
                                                    })
                                                });
                                                const data = await res.json();
                                                if (data.success) {
                                                    setIntentResults(data.data);
                                                    setNotification({ type: 'success', msg: `Classified ${data.stats.totalClusters} clusters. LLM verified: ${data.stats.llmVerified}, Overridden: ${data.stats.llmOverridden}` });
                                                } else {
                                                    setNotification({ type: 'error', msg: data.error });
                                                }
                                            } catch (err) {
                                                setNotification({ type: 'error', msg: 'LLM classification failed' });
                                            }
                                            setIntentLoading(false);
                                        }}
                                        disabled={intentLoading || savedClusters.length === 0}
                                        className="px-4 py-2 bg-purple-600 text-white rounded-lg font-medium disabled:opacity-50"
                                        title="Run rule-based classification + LLM verification for low-confidence clusters"
                                    >
                                        ü§ñ Run + LLM Verify
                                    </button>
                                </div>
                            </div>
                        </div>

                        {/* No results yet */}
                        {!intentResults && !intentLoading && (
                            <div className="bg-white rounded-xl shadow-sm border p-8 text-center">
                                <div className="text-4xl mb-2">üéØ</div>
                                <h3 className="font-bold text-lg mb-1">No Intent Classification Yet</h3>
                                <p className="text-gray-500 text-sm mb-4">
                                    {savedClusters.length === 0
                                        ? 'First generate and save clusters in the Final Clusters tab, then run intent classification.'
                                        : `You have ${savedClusters.length} saved clusters ready for classification. Click "Run Classification" to analyze intent.`}
                                </p>
                                {savedClusters.length === 0 && (
                                    <button onClick={() => setMainTab('clusters')} className="px-4 py-2 bg-indigo-100 text-indigo-700 rounded-lg">
                                        Go to Topic Clusters ‚Üí
                                    </button>
                                )}
                            </div>
                        )}

                        {/* Loading */}
                        {intentLoading && (
                            <div className="bg-white rounded-xl shadow-sm border p-8 text-center">
                                <div className="animate-spin text-4xl mb-2">‚è≥</div>
                                <h3 className="font-bold text-lg">Classifying Intents...</h3>
                                <p className="text-gray-500 text-sm">Analyzing {savedClusters.length} clusters with {savedClusters.reduce((s, c) => s + c.keywords.length, 0)} keywords</p>
                            </div>
                        )}

                        {/* Results */}
                        {intentResults && !intentLoading && (
                            <>
                                {/* Summary Cards */}
                                <div className="bg-gradient-to-r from-indigo-50 to-purple-50 rounded-xl border border-indigo-100 p-4">
                                    <h3 className="font-bold text-indigo-800 mb-3">üìä Intent Distribution Summary</h3>
                                    <div className="grid grid-cols-7 gap-2">
                                        {Object.entries(intentResults.summary).map(([intent, data]) => (
                                            <div key={intent} className={`bg-white rounded-lg p-3 border cursor-pointer hover:shadow-md transition-shadow ${intentFilter === intent ? 'ring-2 ring-indigo-400' : ''}`}
                                                onClick={() => setIntentFilter(intentFilter === intent ? 'all' : intent)}>
                                                <div className="text-xs text-gray-500 truncate capitalize">{intent.replace('_', ' ')}</div>
                                                <div className="text-xl font-bold">{data.clusters}</div>
                                                <div className="text-xs text-gray-400">{data.keywords} kws ‚Ä¢ {(data.volume / 1000).toFixed(0)}k vol</div>
                                            </div>
                                        ))}
                                    </div>
                                </div>

                                {/* Filters and Search */}
                                <div className="bg-white rounded-xl shadow-sm border">
                                    <div className="px-4 py-3 border-b bg-gray-50 flex items-center justify-between gap-4">
                                        <input
                                            type="text"
                                            placeholder="Search clusters..."
                                            value={intentSearch}
                                            onChange={e => setIntentSearch(e.target.value)}
                                            className="flex-1 border rounded px-3 py-1.5 text-sm"
                                        />
                                        <select
                                            value={intentFilter}
                                            onChange={e => setIntentFilter(e.target.value)}
                                            className="border rounded px-2 py-1.5 text-sm bg-white"
                                        >
                                            <option value="all">All Intents</option>
                                            <option value="transactional">Transactional</option>
                                            <option value="commercial_investigation">Commercial Investigation</option>
                                            <option value="informational">Informational</option>
                                            <option value="navigational">Navigational</option>
                                            <option value="local_geo">Local/Geo</option>
                                            <option value="support">Support</option>
                                            <option value="noise">Noise</option>
                                        </select>
                                        <div className="flex items-center gap-2 text-xs">
                                            <span className="text-gray-500">Sort:</span>
                                            {(['confidence', 'volume'] as const).map(s => (
                                                <button
                                                    key={s}
                                                    onClick={() => {
                                                        if (intentSort === s) setIntentSortDir(d => d === 'asc' ? 'desc' : 'asc');
                                                        else { setIntentSort(s); setIntentSortDir('desc'); }
                                                    }}
                                                    className={`px-2 py-1 rounded ${intentSort === s ? 'bg-indigo-100 text-indigo-700' : 'bg-gray-100'}`}
                                                >
                                                    {s === 'confidence' ? 'Confidence' : 'Volume'}
                                                    {intentSort === s && (intentSortDir === 'desc' ? ' ‚Üì' : ' ‚Üë')}
                                                </button>
                                            ))}
                                        </div>
                                    </div>

                                    {/* Cluster List */}
                                    <div className="divide-y max-h-[600px] overflow-y-auto">
                                        {intentResults.clusters
                                            .filter(c => c.clusterName.toLowerCase().includes(intentSearch.toLowerCase()) && (intentFilter === 'all' || c.intentPrimary === intentFilter))
                                            .sort((a, b) => {
                                                const mult = intentSortDir === 'desc' ? -1 : 1;
                                                if (intentSort === 'confidence') return mult * (a.confidence - b.confidence);
                                                return mult * (a.totalVolume - b.totalVolume);
                                            })
                                            .map(c => (
                                                <div key={c.clusterId} className="hover:bg-gray-50">
                                                    <div
                                                        onClick={() => setExpandedIntentCluster(expandedIntentCluster === c.clusterId ? null : c.clusterId)}
                                                        className="p-4 cursor-pointer flex items-start justify-between"
                                                    >
                                                        <div className="flex-1">
                                                            <div className="flex items-center gap-2 mb-1">
                                                                <span className="font-medium">{c.clusterName}</span>
                                                                <span className={`px-2 py-0.5 rounded text-xs font-bold ${c.intentPrimary === 'transactional' ? 'bg-green-100 text-green-700' :
                                                                        c.intentPrimary === 'informational' ? 'bg-blue-100 text-blue-700' :
                                                                            c.intentPrimary === 'commercial_investigation' ? 'bg-amber-100 text-amber-700' :
                                                                                c.intentPrimary === 'navigational' ? 'bg-purple-100 text-purple-700' :
                                                                                    c.intentPrimary === 'local_geo' ? 'bg-teal-100 text-teal-700' :
                                                                                        c.intentPrimary === 'support' ? 'bg-orange-100 text-orange-700' :
                                                                                            'bg-red-100 text-red-700'
                                                                    }`}>
                                                                    {c.intentPrimary.replace('_', ' ')}
                                                                </span>
                                                                {c.intentSecondary && (
                                                                    <span className="px-1.5 py-0.5 bg-gray-100 text-gray-600 rounded text-xs">
                                                                        +{c.intentSecondary.replace('_', ' ')}
                                                                    </span>
                                                                )}
                                                                {c.llmChecked && (
                                                                    <span className={`px-1.5 py-0.5 rounded text-xs ${c.llmOverride ? 'bg-purple-100 text-purple-700' : 'bg-green-100 text-green-700'}`}>
                                                                        {c.llmOverride ? 'ü§ñ LLM Override' : 'ü§ñ LLM Confirmed'}
                                                                    </span>
                                                                )}
                                                            </div>
                                                            <div className="text-sm text-gray-500">
                                                                {c.keywordCount} keywords ‚Ä¢ {c.totalVolume.toLocaleString()} vol
                                                                {c.reasonCodes.length > 0 && (
                                                                    <span className="ml-2 text-amber-600">‚ö† {c.reasonCodes.join(', ')}</span>
                                                                )}
                                                            </div>
                                                        </div>
                                                        <div className="flex items-center gap-3">
                                                            <div className={`text-sm font-bold px-2 py-1 rounded ${c.confidence >= 80 ? 'bg-green-100 text-green-700' :
                                                                    c.confidence >= 60 ? 'bg-amber-100 text-amber-700' :
                                                                        'bg-red-100 text-red-700'
                                                                }`}>
                                                                {c.confidence >= 80 ? '‚úì' : c.confidence >= 60 ? '‚ö†' : '‚ùì'} {c.confidence}%
                                                            </div>
                                                            <span className="text-gray-400">{expandedIntentCluster === c.clusterId ? '‚ñ≤' : '‚ñº'}</span>
                                                        </div>
                                                    </div>

                                                    {/* Expanded: Keyword Details */}
                                                    {expandedIntentCluster === c.clusterId && (
                                                        <div className="px-4 pb-4">
                                                            {/* Distribution Bar */}
                                                            <div className="mb-3">
                                                                <div className="text-xs font-medium text-gray-600 mb-1">Intent Distribution</div>
                                                                <div className="flex h-4 rounded overflow-hidden">
                                                                    {Object.entries(c.distribution)
                                                                        .sort((a, b) => b[1] - a[1])
                                                                        .filter(([, v]) => v > 0.05)
                                                                        .map(([intent, pct]) => (
                                                                            <div
                                                                                key={intent}
                                                                                className={`${intent === 'transactional' ? 'bg-green-400' :
                                                                                        intent === 'informational' ? 'bg-blue-400' :
                                                                                            intent === 'commercial_investigation' ? 'bg-amber-400' :
                                                                                                intent === 'navigational' ? 'bg-purple-400' :
                                                                                                    intent === 'local_geo' ? 'bg-teal-400' :
                                                                                                        intent === 'support' ? 'bg-orange-400' :
                                                                                                            'bg-red-400'
                                                                                    }`}
                                                                                style={{ width: `${pct * 100}%` }}
                                                                                title={`${intent}: ${Math.round(pct * 100)}%`}
                                                                            />
                                                                        ))}
                                                                </div>
                                                                <div className="flex gap-3 mt-1 text-xs text-gray-500">
                                                                    {Object.entries(c.distribution)
                                                                        .sort((a, b) => b[1] - a[1])
                                                                        .slice(0, 4)
                                                                        .map(([intent, pct]) => (
                                                                            <span key={intent}>{intent.replace('_', ' ')}: {Math.round(pct * 100)}%</span>
                                                                        ))}
                                                                </div>
                                                            </div>

                                                            {/* LLM Notes */}
                                                            {c.llmNotes && (
                                                                <div className="mb-3 p-2 bg-purple-50 rounded border border-purple-200 text-sm text-purple-700">
                                                                    ü§ñ <strong>LLM Notes:</strong> {c.llmNotes}
                                                                </div>
                                                            )}

                                                            {/* Request LLM Button */}
                                                            {!c.llmChecked && c.confidence < 70 && (
                                                                <button
                                                                    onClick={async (e) => {
                                                                        e.stopPropagation();
                                                                        try {
                                                                            const res = await fetch('/api/intent/llm-confirm', {
                                                                                method: 'POST',
                                                                                headers: { 'Content-Type': 'application/json' },
                                                                                body: JSON.stringify({ clientCode, clusterId: c.clusterId, cluster: c })
                                                                            });
                                                                            const data = await res.json();
                                                                            if (data.success) {
                                                                                setNotification({ type: 'success', msg: data.data.override ? 'LLM suggested different intent!' : 'LLM confirmed rule-based intent' });
                                                                                // Reload results
                                                                                const reportRes = await fetch(`/api/intent/report?clientCode=${clientCode}`);
                                                                                const reportData = await reportRes.json();
                                                                                if (reportData.success && reportData.data) setIntentResults(reportData.data);
                                                                            }
                                                                        } catch {
                                                                            setNotification({ type: 'error', msg: 'LLM verification failed' });
                                                                        }
                                                                    }}
                                                                    className="mb-3 px-3 py-1.5 bg-purple-100 text-purple-700 rounded text-sm"
                                                                >
                                                                    ü§ñ Request LLM Review
                                                                </button>
                                                            )}

                                                            {/* Keyword Table */}
                                                            <div className="bg-gray-50 rounded-lg overflow-hidden">
                                                                <table className="w-full text-sm">
                                                                    <thead className="bg-gray-100">
                                                                        <tr>
                                                                            <th className="text-left px-3 py-2">Keyword</th>
                                                                            <th className="text-right px-3 py-2">Vol</th>
                                                                            <th className="text-left px-3 py-2">Intent</th>
                                                                            <th className="text-center px-3 py-2">Conf</th>
                                                                            <th className="text-left px-3 py-2">Matched Rules</th>
                                                                        </tr>
                                                                    </thead>
                                                                    <tbody className="divide-y">
                                                                        {c.keywords
                                                                            .sort((a, b) => b.volume - a.volume)
                                                                            .slice(0, 20)
                                                                            .map((k, i) => (
                                                                                <tr key={i} className="hover:bg-white">
                                                                                    <td className="px-3 py-2 font-medium">{k.keyword}</td>
                                                                                    <td className="px-3 py-2 text-right text-gray-500">{k.volume.toLocaleString()}</td>
                                                                                    <td className="px-3 py-2">
                                                                                        <span className={`px-1.5 py-0.5 rounded text-xs ${k.intentPrimary === 'transactional' ? 'bg-green-100 text-green-700' :
                                                                                                k.intentPrimary === 'informational' ? 'bg-blue-100 text-blue-700' :
                                                                                                    k.intentPrimary === 'commercial_investigation' ? 'bg-amber-100 text-amber-700' :
                                                                                                        'bg-gray-100 text-gray-600'
                                                                                            }`}>
                                                                                            {k.intentPrimary.replace('_', ' ')} ({Math.round((k.intentProbs[k.intentPrimary] || 0) * 100)}%)
                                                                                        </span>
                                                                                    </td>
                                                                                    <td className="px-3 py-2 text-center">{k.confidence}</td>
                                                                                    <td className="px-3 py-2 text-xs text-gray-400 truncate max-w-xs">{k.matchedRules.slice(0, 3).join(', ')}</td>
                                                                                </tr>
                                                                            ))}
                                                                    </tbody>
                                                                </table>
                                                                {c.keywords.length > 20 && (
                                                                    <div className="px-3 py-2 text-xs text-gray-500 bg-gray-100">
                                                                        Showing top 20 of {c.keywords.length} keywords
                                                                    </div>
                                                                )}
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>
                                            ))}
                                    </div>
                                </div>

                                {/* Export */}
                                <div className="flex justify-end">
                                    <button
                                        onClick={() => {
                                            if (!intentResults) return;
                                            const headers = ['Cluster', 'Primary Intent', 'Secondary Intent', 'Confidence', 'Keywords', 'Volume', 'LLM Checked', 'LLM Override'];
                                            const rows = intentResults.clusters.map(c => [
                                                c.clusterName,
                                                c.intentPrimary,
                                                c.intentSecondary || '',
                                                c.confidence,
                                                c.keywordCount,
                                                c.totalVolume,
                                                c.llmChecked ? 'Yes' : 'No',
                                                c.llmOverride ? 'Yes' : 'No'
                                            ]);
                                            const csv = [headers.join(','), ...rows.map(r => r.map(c => `"${c}"`).join(','))].join('\n');
                                            const blob = new Blob([csv], { type: 'text/csv' });
                                            const a = document.createElement('a');
                                            a.href = URL.createObjectURL(blob);
                                            a.download = `intent-report-${clientCode}.csv`;
                                            a.click();
                                        }}
                                        className="px-4 py-2 bg-green-600 text-white rounded-lg"
                                    >
                                        üì• Export Intent Report CSV
                                    </button>
                                </div>
                            </>
                        )}
                    </div>
                )}
            </div>
        </div>
    );
}
